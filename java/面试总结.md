摩宝  2022年1月19日

1. 如何创建整形变量

   <details>
     <summary>解答</summary>
     <pre><code>
     1.直接编写不需要new
     2.new Integer
     </code></pre>
   </details>

2. int和integer区别

   <details>
     <summary>解答</summary>
     <pre><code>
     1.int 是基本类型，直接存数值 存在于，Integer是一个对象，用一个引用指向这个对象
     2.在初始化的时候 int是0，Integer是null
     扩展内容：自动装箱和自动拆箱，静态常量池
     </code></pre>
   </details>

3. 如何判断数组为空

4. size和isEmpty()区别，性能？

   <details>
     <summary>解答</summary>
     <pre><code>
     public boolean isEmpty() {
           return size == 0;
       }
       public int size() {
           return size;
       }
       1.isEmpty更具有表现力（代码更易于阅读和维护）
       2.isEmpty更快（需要看实现方法，比如是 ConcurrentLinkedQueue 底层直接使用开头是否为空来判断）
       public int size() {
           int count = 0;
           for (Node<E> p = first(); p != null; p = succ(p))
               if (p.item != null)
                   // Collection.size() spec says to max out
                   if (++count == Integer.MAX_VALUE)
                       break;
           return count;
       }
       public boolean isEmpty() {
           return findFirst() == null;
       }
    </code></pre>
   </details>

5. 数据库连接池原理

   <details>
     <summary>解答</summary>
     <pre><code>
   	在应用程序启动时创建足够的数据库连接，由应用程序动态对池中的连接进行申请，使用和释放；
   	有两个比较重要的参数：最小连接数和最大连接数
   	1.如果当前连接数小于最小连接数，则创建新的连接处理请求
   	2.如果连接池中有空闲连接则复用空闲连接；
   	3.如果空闲池中没有连接并且当前连接数大于最大连接数，则创建新的连接处理请求
   	4.如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
   	5.如果等待超过了这个设定时间则向用户抛出错误。
     </code></pre>
   </details>

6. druid连接池的实现原理

7. 幂等性是什么意思

   <details>
     <summary>解答</summary>
     <pre><code>
   	某个行为重复的执行，最终获取的结果是相同的，不会应为重复的执行对系统造成变化。
     </code></pre>
   </details>

8. 如何实现幂等性

   <details>
     <summary>解答</summary>
     <pre><code>
   	1.在数据库层面添加唯一索引
   	2.乐观锁（添加版本号）
   	3.悲观锁（直接上锁）
   	4.token令牌（每次请求之前获取token，服务器将token存在Redis，然后请求的时候进行token校验）
     </code></pre>
   </details>

9. 现有的框架如何升级迭代能扛住2000W的并发、

   <details>
     <summary>解答</summary>
     <pre><code>
   	1.Tomcat于数据分开部署
   	2.引入本地缓存和分布式缓存
   	3.引入反向代理实现负载均衡
   	4.数据库读写分离
   	5.数据库按业务分库
   	6.把大表拆分成小表
   	7.使用LVS或F5来使多个Nginx负载均衡
   	8.通过DNS轮询实现机房间的负载均衡
   	9.引入NoSQL数据库和搜索引擎等技术
   	10.大应用拆分为小应用
   	11.复用的功能抽离成微服务
   	12.引入企业服务总线ESB屏蔽服务接口的访问差异
   	13.引入容器化技术实现运行环境隔离与动态服务管理
   	14.以云平台承载系统
     </code></pre>
   </details>



