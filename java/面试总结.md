# 摩宝  2022年1月19日

1. 如何创建整形变量

   <details>
     <summary>解答</summary>
     <pre><code>
     1.直接编写不需要new
     2.new Integer
     </code></pre>
   </details>

2. int和integer区别

   <details>
     <summary>解答</summary>
     <pre><code>
     1.int 是基本类型，直接存数值 存在于，Integer是一个对象，用一个引用指向这个对象
     2.在初始化的时候 int是0，Integer是null
     扩展内容：自动装箱和自动拆箱，静态常量池
     </code></pre>
   </details>

3. 如何判断数组为空

4. size和isEmpty()区别，性能？

   <details>
     <summary>解答</summary>
     <pre><code>
     public boolean isEmpty() {
           return size == 0;
       }
       public int size() {
           return size;
       }
       1.isEmpty更具有表现力（代码更易于阅读和维护）
       2.isEmpty更快（需要看实现方法，比如是 ConcurrentLinkedQueue 底层直接使用开头是否为空来判断）
       public int size() {
           int count = 0;
           for (Node<E> p = first(); p != null; p = succ(p))
               if (p.item != null)
                   // Collection.size() spec says to max out
                   if (++count == Integer.MAX_VALUE)
                       break;
           return count;
       }
       public boolean isEmpty() {
           return findFirst() == null;
       }
    </code></pre>
   </details>

5. 数据库连接池原理

   <details>
     <summary>解答</summary>
     <pre><code>
   	在应用程序启动时创建足够的数据库连接，由应用程序动态对池中的连接进行申请，使用和释放；
   	有两个比较重要的参数：最小连接数和最大连接数
   	1.如果当前连接数小于最小连接数，则创建新的连接处理请求
   	2.如果连接池中有空闲连接则复用空闲连接；
   	3.如果空闲池中没有连接并且当前连接数大于最大连接数，则创建新的连接处理请求
   	4.如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
   	5.如果等待超过了这个设定时间则向用户抛出错误。
     </code></pre>
   </details>

6. druid连接池的实现原理

7. 幂等性是什么意思

   <details>
     <summary>解答</summary>
     <pre><code>
   	某个行为重复的执行，最终获取的结果是相同的，不会应为重复的执行对系统造成变化。
     </code></pre>
   </details>

8. 如何实现幂等性

   <details>
     <summary>解答</summary>
     <pre><code>
   	1.在数据库层面添加唯一索引
   	2.乐观锁（添加版本号）
   	3.悲观锁（直接上锁）
   	4.token令牌（每次请求之前获取token，服务器将token存在Redis，然后请求的时候进行token校验）
     </code></pre>
   </details>

9. 现有的框架如何升级迭代能扛住2000W的并发

   <details>
     <summary>解答</summary>
     <pre><code>
   	1.Tomcat于数据分开部署
   	2.引入本地缓存和分布式缓存
   	3.引入反向代理实现负载均衡
   	4.数据库读写分离
   	5.数据库按业务分库
   	6.把大表拆分成小表
   	7.使用LVS或F5来使多个Nginx负载均衡
   	8.通过DNS轮询实现机房间的负载均衡
   	9.引入NoSQL数据库和搜索引擎等技术
   	10.大应用拆分为小应用
   	11.复用的功能抽离成微服务
   	12.引入企业服务总线ESB屏蔽服务接口的访问差异
   	13.引入容器化技术实现运行环境隔离与动态服务管理
   	14.以云平台承载系统
     </code></pre>
   </details>

# 浩鲸 1面（电话） 2022年2月15日

1. 说说熟悉的集合，问了HashMap的底层，创建HashMap时写的参数，比如说 ==new Hashmap<>(5)==,数组长度是多少？

   <details>
     <summary>解答</summary>
     <pre><code>
     // 将参数换算为 比它大切最接近的 2次方数值
   	static final int tableSizeFor(int cap) {
           int n = cap - 1;
           n |= n >>> 1;
           n |= n >>> 2;
           n |= n >>> 4;
           n |= n >>> 8;
           n |= n >>> 16;
           return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
       }
       </code></pre>
   </details>

2. 链表和红黑树的时间复杂度，为什么使用红黑树？

   <details>
     <summary>解答</summary>
     <pre><code>
     	  数组	   链表	  二叉树	二叉排序树	     红黑树
   查找	O(N)	O(N)	O(N)	O(log2N)~O(N)	O(log2N)
       </code></pre>
   </details>

3. HashSet底层，key,value存的什么值

   <details>
     <summary>解答</summary>
     <pre><code>
     	   1.底层直接是new HashMap()
     	   2.key:set.add()的值，value:Object PRESENT = new Object(); object 对象
     </code></pre>
    </details>

4. 并发集合，例如：ConcurrentHashMap

5. 除了ConcurrentHashMap还有什么？

   <details>
     <summary>解答</summary>
     <pre><code>
     	    - **`ConcurrentHashMap`** : 线程安全的 `HashMap`
   		- **`CopyOnWriteArrayList`** : 线程安全的 `List`，在读多写少的场合性能非常好，远远好于 `Vector`。
   		- **`ConcurrentLinkedQueue`** : 高效的并发队列，使用链表实现。可以看做一个线程安全的 `LinkedList`，这是一个非阻塞队列。
   		- **`BlockingQueue`** : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
   		- **`ConcurrentSkipListMap`** : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。
     </code></pre>
    </details>

6. 说一说AQS，底层是什么

   <details>
     <summary>解答</summary>
     <pre><code>
     	  请求资源的线程，将共享资源设置为锁状态。如果共享资源被占用了，提供了一套阻塞和唤醒时锁分配机制，这个机制是利用CLH队列实现的，即使获取不到锁，也会加入队列之中。
     </code></pre>
    </details>

7. ReentrantLock中的公平锁和非公平锁？

   <details>
     <summary>解答</summary>
     <pre><code>
     	  公平锁：按照队列中的顺序来唤醒，先到的先拿到锁
     	  非公平锁：首先在第一调用的时候就会直接先进行一次CAS，成功就返回，非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。
     </code></pre>
    </details>

8. netty的线程模型

   <details>
     <summary>解答</summary>
     <pre><code>
     	  1. netty单线程模型
     	  	所有的I/O 操作都是在同一个NIO线程上完成的，此时的NIO的责任包括：接收创建线程连接，读写操作等
     	  2. Reactor多线程模型
     	  	有一组NIO线程来处理连接读写操作，一个NIO线程处理Accept。一个NIO线程可以处理多个连接事件。
     	  3. Reactor主从多线程模型
     	  	一个单独的NIO线程池来处理连接请求，有一组NIO线程来处理连接之后的读写操作。
     </code></pre>
    </details>

9. netty的==epoll==  BUG 

   <details>
     <summary>解答</summary>
     <pre><code>
     	  原因：select()操作是阻塞的，只有被监听的fd有读写操作时，才被唤醒。但是，在这个bug中，没有任何fd有读写请求，但是select()操作依旧被唤醒很显然，这种情况下，selectedKeys()返回的是个空数组，然后按照逻辑执行到while(true)处，循环执行，导致死循环。
     	  解决方法：
     	  1. 对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数。
   	  2. 若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。
   	  3. 重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。使用新的Selector进行替换。
     </code></pre>
    </details>

10. JVM 内存模型，堆的分布

11. 对象创建过程（JVM层面描述）

    <details>
      <summary>解答</summary>
      <pre><code>
      	  1. 类加载检测
      	  2. 内存分配
      	  3. 初始化零值
      	  4. 设置对象头
      	  5.执行init方法
      </code></pre>
     </details>

12. 类加载的过程

    <details>
      <summary>解答</summary>
      <pre><code>
      	  1. 加载
      	  2. 连接
      	  	1. 验证
      	  	2. 准备
      	  	3. 解析
      	  3. 初始化
      	  4. 使用
      	  5. 卸载
      </code></pre>
     </details>

13. 收集方法

14. 收集器

15. mysql索引失效，Explain中的 type 类型

    <details>
      <summary>解答</summary>
      <pre><code>
      	 system > const > eq_ref > ref > range > index > ALL
      </code></pre>
     </details>

16. 线程池 的参数，具体流程是什么

17. spring  怎么处理循环依赖的

18. 三级缓存？二级缓存？一级缓存？

    <details>
      <summary>解答</summary>
      <pre><code>
      	 一级缓存？
      	 	如果使用一级缓存，就会存在未赋值对象和已赋值对象混合在一起，会出现空指针异常
         二级缓存？
         	在普通的依赖循环是没问题的，但时候如果是出现代理对象就会有问题，因为如果Bean 是被代理的话，就需要就将代理对象进行缓存。如果是在创建对象之前就只直接进行代理，这样子就违背了IOC和AOP的设计原理了。如果必须要保持这个原理就需要使用三级缓存，可以直接在二级缓存中存代理对象和objectFactory， 这样子就显得二级缓存很混乱。
      </code></pre>
     </details>

19. spring 怎么实现 AOP的？JDK和CGLIB有什么区别？

    <details>
      <summary>解答</summary>
      <pre><code>
      	 JDK：利用拦截器加上反射生产一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
      	 CGLIB：利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
      </code></pre>
     </details>

20. AOP中分别对同一个Bean做了两次代理，请问这个Bean的方法怎么执行

21. 分布式事务和分布式锁的实现？技术选型

# 浩鲸 2面（现场） 2022年2月17日

聊为什么离职，聊项目，从项目问技术

大体问题：

1. K8s的负载策略
2. 分布式锁的实现
3. mysql 两个字段同时修改数据，怎么保证并发安全
