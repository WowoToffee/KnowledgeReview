# 容器

容器，到底是怎么一回事儿？

```
容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。
容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。
```



docker 的流行原因：

```
2013~2014 年，以 Cloud Foundry 为代表的 PaaS 项目，逐渐完成了教育用户和开拓市场的艰巨任务，也正是在这个将概念逐渐落地的过程中，应用“打包”困难这个问题，成了整个后端技术圈子的一块心病。
Docker 项目的出现，则为这个根本性的问题提供了一个近乎完美的解决方案(镜像)。这正是Docker 项目刚刚开源不久，就能够带领一家原本默默无闻的 PaaS 创业公司脱颖而出，然后迅速占领了所有云计算领域头条的技术原因。
```

## docker核心实现

### Namespace机制

```
Docker 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。
```

==**容器，其实是一种特殊的进程而已。**==

| 名称              | -                                                     |
| ----------------- | ----------------------------------------------------- |
| Mount Namespace   | 用于让被隔离进程只看到当前 Namespace 里的挂载点信息； |
| Network Namespace | 用于让被隔离进程看到当前 Namespace 里的网络设备和配置 |



### Cgroups

**Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。**

### **rootfs（根文件系统）**

现在我们知道，容器技术的核心就是通过 `Namespace` 限制了容器看到的视野，通过 `Cgroup`限制了容器可访问的资源。 但关于 `Mount Namespace` 还有一些特殊的地方，需要着重关注下。

`Mount Namespace` 特殊之处在于，除了在修改时需要进程对文件系统挂载点的认证，还需要显式声明需要挂载那些目录。在 Linux 系统中，有一个叫 `chroot` 的命令，可以改变进程的根目录到指定的位置。而 `Mount Namespace` 正是基于 chroot 的基础上发展出来的。

在容器内，应该看到完全独立的文件系统，而且不会受到宿主机以及其他容器的影响。这个独立的文件系统，就叫做**容器镜像**。它还有一个更专业的名字叫 `rootfs.` `rootfs` 中包含了一个操作系统所需要的文件，配置和目录，**但并不包含系统内核。** 因为在 Linux 中，文件和内核是分开存放的，操作系统只有在开启启动时才会加载指定的内核。这也就意味着，所有的容器都会**共享宿主机上操作系统的内核。**

容器的rootfs分为三个部分:

- 可读层(rw)

  专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。

- init层(ro+wh)

  Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。用于配置每个容器自定义的配置。

- 只读层(ro+wh)（操作系统需要的文件）

### 容器的启动过程

1. 启用 Linux Namespace 配置；
2. 设置指定的 Cgroups 参数；
3. 切换进程的根目录（Change Root）。

 ### **Volume** 

volume 挂载的文件不会在docker commit 时提交掉。

# Kubernetes 

Kubernetes 核心技术在于将docker 进行编排，提供路由网关、水平扩展、监控、备份、灾难恢复等一系列运维能力。

控制节点，即 Master 节点，由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。