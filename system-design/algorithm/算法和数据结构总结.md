# 一维

## 基本：

1. 数组 array(string)
2. 链表 linkdList

## 高级：

1. 栈 stack
2. 队列 queue
3. 双端队列 deque
4. 集合 set 
5. 映射 map, (Hash or map), etc

# 二维

## 基本：

1. 树 tree

2. 图 gragh

   

## 高级：

1. 二叉搜索树 binary search tree (red-black tree, AVL)

2. 堆 heap 

3. 并查集 disjoint set

4. 字典树 trie, etc

   

# 特殊

1. 位运算
2. 布隆过滤器
3. LRU Cache



三大点：拆分知识点，可以联系，反馈

五毒神掌： 第一步多想，第二步默写，第三步第二天默写，第四步一周之后默写，第五步面试之前复习

2022年3月2日

1.  [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
2.  [ 移动零](https://leetcode-cn.com/problems/move-zeroes/)
3.  [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
4. [三数之和](https://leetcode-cn.com/problems/3sum/)

2022年3月3日

1. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

2. #### [最小栈](https://leetcode-cn.com/problems/min-stack/)

3. [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

   ```java
   public class Solution {
   
       public int largestRectangleArea(int[] heights) {
           int len = heights.length;
           if (len == 0) {
               return 0;
           }
           if (len == 1) {
               return heights[0];
           }
   
           int res = 0;
           Deque<Integer> deque = new ArrayDeque<>();
           for (int i = 0; i < len; i ++) {
               while (!deque.isEmpty() && heights[i] < heights[deque.peekLast()]) {
                   int curHeight = heights[deque.pollLast()];
                   // 找连续相同数据
                   while (!deque.isEmpty() && heights[deque.peekLast()] == curHeight) {
                       deque.pollLast();
                   }
                   int curWidth;
                   if (deque.isEmpty()) {
                       curWidth = i;
                   } else {
                       curWidth = i - deque.peekLast() - 1;
                   }
                   res = Math.max(res, curWidth * curHeight);
               }
               deque.addLast(i);
           }
   
           while (!deque.isEmpty()) {
               int curHeight = heights[deque.pollLast()];
               // 找连续相同数据
               while (!deque.isEmpty() && heights[deque.peekLast()] == curHeight) {
                   deque.pollLast();
               }
               int curWidth;
               if (deque.isEmpty()) {
                   curWidth = len;
               } else {
                   curWidth = len - deque.peekLast() - 1;
               }
               res = Math.max(res, curWidth * curHeight);
           }
           return res;
       }
   }
   ```

   数组存储

   ```java
   class Solution {
       public int largestRectangleArea(int[] heights) {
           int n = heights.length;
           int[] left = new int[n];
           int[] right = new int[n];
           Arrays.fill(right, n);
   
           Deque<Integer> deque = new ArrayDeque<>();
   
           for(int i = 0; i < n; i++) {
               while (!deque.isEmpty() && heights[deque.peek()] >= heights[i]) {
                   right[deque.peek()] = i;
                   deque.pop();
               }
               left[i] = (deque.isEmpty() ? -1 : deque.peek());
               deque.push(i);
           }
   
           int ans = 0;
           for (int i = 0; i < n; ++i) {
               ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);
           }
           return ans;
       }
   }
   
   
   ```

   

4. #### [ 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

   ```java
   class Solution {
       public int[] maxSlidingWindow(int[] nums, int k) {
           if(nums.length == 1) {
               return nums;
           }
           Deque<Integer> deque = new ArrayDeque<>();
           int[] arr = new int[nums.length - k + 1];
           for (int i = 0; i < nums.length; i++) {
               while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                   deque.pollLast();
               }
               deque.addLast(i);
   
               if (deque.peek() < i - k) {
                   deque.poll();
               }
   
               if (i >= k -1) {
                   arr[i - k +1] = nums[deque.peek()];
               }
           }
           return arr;
       }
   }
   ```

   

2022年3月10日

1. #### [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

2. #### [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

3. #### [两数之和](https://leetcode-cn.com/problems/two-sum/)

2022年3月11日

重点：牢记前中后序。

1. #### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

2. #### [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

3. #### [N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

4. #### [N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

5. #### [N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

2022年3月21日

1. #### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（递归解法）

2.  [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)(多练习)

   **暴力算法**

   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<String> combinations = new ArrayList<String>();
           generateAll(new char[2 * n], 0, combinations);
           return combinations;
       }
   
       public void generateAll(char[] current, int pos, List<String> result) {
           if (pos == current.length) {
               if (valid(current)) {
                   result.add(new String(current));
               }
           } else {
               current[pos] = '(';
               generateAll(current, pos + 1, result);
               current[pos] = ')';
               generateAll(current, pos + 1, result);
           }
       }
   
       public boolean valid(char[] current) {
           int balance = 0;
           for (char c: current) {
               if (c == '(') {
                   ++balance;
               } else {
                   --balance;
               }
               if (balance < 0) {
                   return false;
               }
           }
           return balance == 0;
       }
   }
   
   ```

   **回溯**

   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<String> ans = new ArrayList<String>();
           backtrack(ans, new StringBuilder(), 0, 0, n);
           return ans;
       }
   
       public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {
           if (cur.length() == max * 2) {
               ans.add(cur.toString());
               return;
           }
           if (open < max) {
               cur.append('(');
               backtrack(ans, cur, open + 1, close, max);
               cur.deleteCharAt(cur.length() - 1);
           }
           if (close < open) {
               cur.append(')');
               backtrack(ans, cur, open, close + 1, max);
               cur.deleteCharAt(cur.length() - 1);
           }
       }
   }
   
   ```

   **深度优先遍历**

   ```java
   class Solution {
   
   
       public List<String> generateParenthesis(int n) {
           List<String> res = new ArrayList<>();
           if (n == 0) {
               return res;
           }
           dfs("", n, n, res);
           return res;
       }
   
       private void dfs(String curStr, int left, int right, List<String> res) {
           if (left == 0 && right == 0) {
               res.add(curStr);
               return;
           }
   
           if (left > right) {
               return;
           }
   
           if (left > 0) {
               dfs(curStr + "(", left - 1, right, res);
           }
   
           if (right > 0) {
               dfs(curStr + ")", left, right - 1, res);
           }
   
       }
   }
   ```

   

3. #### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

4. #### [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

5.  [ 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

6.  [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

7.  [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

2022年3月24日

1. #### [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

2. #### [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

   **常规思想**

   ```java
   class Solution {
   
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           return buildTreeHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
       }
   
       private TreeNode buildTreeHelper(int[] preorder, int p_start, int p_end, int[] inorder, int i_start, int i_end) {
   
           // preorder 为空，直接返回 null
           if (p_start == p_end) {
               return null;
           }
   
           int root_val = preorder[p_start];
           TreeNode root = new TreeNode(root_val);
   
           // 在中序遍历找到根节点位置
           int i_root_index = 0;
           for (int i = i_start; i < i_end; i++) {
               if (inorder[i] == root_val) {
                   i_root_index = i;
                   break;
               }
           }
   
           // 当前循环的范围
           int leftNum = i_root_index - i_start;
           // p_start + 1: preorder 向右移动，找到左节点（因为是前序遍历）
           // p_start + leftNum + 1: 限制 preorder 该层树节点具体范围
           // i_start: 中序节点的开始
           // i_root_index: 该层节点的结束位置
           root.left = buildTreeHelper(preorder, p_start + 1,  p_start + leftNum + 1 , inorder, i_start, i_root_index);
           // p_start + leftNum + 1: 因为是前序遍历，该层最后一位一定是右节点
           // i_root_index + 1: 为后续递归做主备
           root.right = buildTreeHelper(preorder, p_start + leftNum + 1, p_end, inorder, i_root_index + 1, i_end);
           return root;
       }
   }
   ```

   

3. #### [组合](https://leetcode-cn.com/problems/combinations/)

   **初始版** 使用for 循环来代替第二次递归

   ```java
   public class Solution {
   
       public List<List<Integer>> combine(int n, int k) {
           List<List<Integer>> res = new ArrayList<>();
           if (k <= 0 || n < k) {
               return res;
           }
           Deque<Integer> path = new ArrayDeque<>();
           dfs(n, k, 1, path, res);
           return res;
       }
   
       private void dfs(int n, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {
           if (path.size() == k) {
               res.add(new ArrayList<>(path));
               return;
           }
           for (int i = begin; i <= n; i++) {
               path.addLast(i);
               System.out.println("递归之前 => " + path);
               dfs(n, k, i + 1, path, res);
               path.removeLast();
               System.out.println("递归之后 => " + path);
           }
       }
   
       public static void main(String[] args) {
           Solution solution = new Solution();
           int n = 5;
           int k = 3;
           List<List<Integer>> res = solution.combine(n, k);
           System.out.println(res);
       }
   }
   
   ```

   **第二次优化循环** 因为在循环到 n - begin+1  <k 的时候已经无法凑齐k位数

   ```java
   import java.util.ArrayDeque;
   import java.util.ArrayList;
   import java.util.Deque;
   import java.util.List;
   
   public class Solution {
   
       public List<List<Integer>> combine(int n, int k) {
           List<List<Integer>> res = new ArrayList<>();
           if (k <= 0 || n < k) {
               return res;
           }
           Deque<Integer> path = new ArrayDeque<>();
           dfs(n, k, 1, path, res);
           return res;
       }
   
       private void dfs(int n, int k, int index, Deque<Integer> path, List<List<Integer>> res) {
           if (path.size() == k) {
               res.add(new ArrayList<>(path));
               return;
           }
   
           // 只有这里 i <= n - (k - path.size()) + 1 与参考代码 1 不同
           for (int i = index; i <= n - (k - path.size()) + 1; i++) {
               path.addLast(i);
               dfs(n, k, i + 1, path, res);
               path.removeLast();
           }
       }
   }
   
   ```

   **双层递归** 

   ```java
   import java.util.ArrayDeque;
   import java.util.ArrayList;
   import java.util.Deque;
   import java.util.List;
   
   public class Solution {
   
       public List<List<Integer>> combine(int n, int k) {
           List<List<Integer>> res = new ArrayList<>();
           if (k <= 0 || n < k) {
               return res;
           }
   
           // 为了防止底层动态数组扩容，初始化的时候传入最大长度
           Deque<Integer> path = new ArrayDeque<>(k);
           dfs(1, n, k, path, res);
           return res;
       }
   
       private void dfs(int begin, int n, int k, Deque<Integer> path, List<List<Integer>> res) {
           if (k == 0) {
               res.add(new ArrayList<>(path));
               return;
           }
   
           // 基础版本的递归终止条件：if (begin == n + 1) {
           if (begin > n - k + 1) {
               return;
           }
           // 不选当前考虑的数 begin，直接递归到下一层
           dfs(begin + 1, n, k, path, res);
   
           // 不选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数
           path.addLast(begin);
           dfs(begin + 1, n, k - 1, path, res);
           // 深度优先遍历有回头的过程，因此需要撤销选择
           path.removeLast();
       }
   }
   
   ```

   

4. #### [全排列](https://leetcode-cn.com/problems/permutations/)

5. [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)（重点理解如何剪枝）

2022年4月2日

1.  [ Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)
2.  [子集](https://leetcode-cn.com/problems/subsets/)

**参考链接**

· [牛顿迭代法原理](http://www.matrix67.com/blog/archives/361)

· [牛顿迭代法代码](http://www.voidcn.com/article/p-eudisdmk-zm.html)
