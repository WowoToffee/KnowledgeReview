# 一维

## 基本：

1. 数组 array(string)
2. 链表 linkdList

## 高级：

1. 栈 stack
2. 队列 queue
3. 双端队列 deque
4. 集合 set 
5. 映射 map, (Hash or map), etc

# 二维

## 基本：

1. 树 tree

2. 图 gragh

   

## 高级：

1. 二叉搜索树 binary search tree (red-black tree, AVL)

2. 堆 heap 

3. 并查集 disjoint set

4. 字典树 trie, etc

   

# 特殊

1. 位运算
2. 布隆过滤器
3. LRU Cache



三大点：拆分知识点，可以联系，反馈

五毒神掌： 第一步多想，第二步默写，第三步第二天默写，第四步一周之后默写，第五步面试之前复习

2022年3月2日

1.  [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
2.  [ 移动零](https://leetcode-cn.com/problems/move-zeroes/)
3.  [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
4. [三数之和](https://leetcode-cn.com/problems/3sum/)

2022年3月3日

1. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

2. #### [最小栈](https://leetcode-cn.com/problems/min-stack/)

3.  [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

4. #### [ 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

2022年3月10日

1. #### [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

2. #### [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

3. #### [两数之和](https://leetcode-cn.com/problems/two-sum/)

2022年3月11日

重点：牢记前中后序。

1. #### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

2. #### [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

3. #### [N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

4. #### [N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

5. #### [N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

2022年3月21日

1. #### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（递归解法）

2.  [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

   **暴力算法**

   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<String> combinations = new ArrayList<String>();
           generateAll(new char[2 * n], 0, combinations);
           return combinations;
       }
   
       public void generateAll(char[] current, int pos, List<String> result) {
           if (pos == current.length) {
               if (valid(current)) {
                   result.add(new String(current));
               }
           } else {
               current[pos] = '(';
               generateAll(current, pos + 1, result);
               current[pos] = ')';
               generateAll(current, pos + 1, result);
           }
       }
   
       public boolean valid(char[] current) {
           int balance = 0;
           for (char c: current) {
               if (c == '(') {
                   ++balance;
               } else {
                   --balance;
               }
               if (balance < 0) {
                   return false;
               }
           }
           return balance == 0;
       }
   }
   
   ```

   **回溯**

   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<String> ans = new ArrayList<String>();
           backtrack(ans, new StringBuilder(), 0, 0, n);
           return ans;
       }
   
       public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {
           if (cur.length() == max * 2) {
               ans.add(cur.toString());
               return;
           }
           if (open < max) {
               cur.append('(');
               backtrack(ans, cur, open + 1, close, max);
               cur.deleteCharAt(cur.length() - 1);
           }
           if (close < open) {
               cur.append(')');
               backtrack(ans, cur, open, close + 1, max);
               cur.deleteCharAt(cur.length() - 1);
           }
       }
   }
   
   ```

   **深度优先遍历**

   ```java
   class Solution {
   
   
       public List<String> generateParenthesis(int n) {
           List<String> res = new ArrayList<>();
           if (n == 0) {
               return res;
           }
           dfs("", n, n, res);
           return res;
       }
   
       private void dfs(String curStr, int left, int right, List<String> res) {
           if (left == 0 && right == 0) {
               res.add(curStr);
               return;
           }
   
           if (left > right) {
               return;
           }
   
           if (left > 0) {
               dfs(curStr + "(", left - 1, right, res);
           }
   
           if (right > 0) {
               dfs(curStr + ")", left, right - 1, res);
           }
   
       }
   }
   ```

   

3. #### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

4. #### [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

5.  [ 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

6.  [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

7.  [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

2022年3月24日

1. #### [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

2. #### [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

3. #### [组合](https://leetcode-cn.com/problems/combinations/)

4. #### [全排列](https://leetcode-cn.com/problems/permutations/)

5.  [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)



